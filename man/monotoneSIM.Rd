% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/monotoneSIM_wrapper.R
\name{monotoneSIM}
\alias{monotoneSIM}
\title{Bayesian Estimation of Monotone Single Index Models}
\usage{
monotoneSIM(
  y,
  X,
  beta.init,
  xi.init,
  Sigma.xi,
  knots = NULL,
  monotone = TRUE,
  iter.HMC = 10,
  sigma.sq.beta = 1,
  sigma.sq.eps.init = 1,
  a.eps = 1,
  b.eps = 1,
  Burn.in = 100,
  M = 1000
)
}
\arguments{
\item{y}{\eqn{n x 1} Vector of Response Variable.}

\item{X}{\eqn{n x p} Matrix of Predictors. Each row represents a \eqn{p x 1} predictor vector.}

\item{beta.init}{\eqn{p x 1} Vector; Starting value of Single index parameter, \eqn{\beta} for the algorithm.}

\item{xi.init}{\eqn{(L+1) x 1} Vector; Starting value of B-Spline Basis Coefficients, \eqn{\xi} for the algorithm. All elements of \code{xi.init} should be non-negative if \code{monotone = TRUE}.}

\item{Sigma.xi}{\eqn{(L+1) X (L+1)} Matrix; Hyperparameter specifying prior Variance of \eqn{\xi}.}

\item{knots}{\eqn{(L+1) X 1} Vector of user supplied knots, that are used to define the B-Spline basis functions. Takes \code{NULL} by default. If \code{NULL}, equispaced knots in \eqn{[-1, 1]} are chosen for the algorithm.}

\item{monotone}{Logical; Takes \code{TRUE} by default. If \code{TRUE}, the link function is taken to be monotone and the posterior of \eqn{\xi} is drawn from a Truncated Normal distribution by an exact Hamiltonian Monte Carlo algorithm. If \code{FALSE},  the posterior of \eqn{\xi} is drawn from a Normal distribution.}

\item{iter.HMC}{Positive integer; Number of iterations of the Hamiltonian Monte Carlo algorithm in Truncated Normal sampling if \code{monotone = TRUE}. Takes the value \eqn{10} by default.}

\item{sigma.sq.beta}{Scalar; Hyperparameter specifying prior Variance of beta. Takes the value \eqn{1} by default.}

\item{sigma.sq.eps.init}{Scalar; Starting value of Error Variance. Takes the value \eqn{1} by default.}

\item{a.eps}{Scalar; Hyperparameter specifying shape of the prior Inverse Gamma distirbution of sigma.sq.eps. Takes the value \eqn{1} by default.}

\item{b.eps}{Scalar; Hyperparameter specifying rate of the prior Inverse Gamma distirbution of sigma.sq.eps. Takes the value \eqn{1} by default.}

\item{Burn.in}{Non-negative integer; Burn-in period of the Markov Chain Monte Carlo algorithm. Takes the value \eqn{100} by default.}

\item{M}{Positive integer; Required size of the  Markov Chain Monte Carlo sample. Takes the value \eqn{1000} by default.}
}
\value{
A list with the following elements.
\item{xi}{ \code{M} \eqn{x (L+1)} Matrix of Basis Coefficients. Each row represent one sample from the Conditional posterior of basis coefficients.}
\item{beta.Xscaled}{ \code{M} \eqn{x p} Matrix of parameters corresponding to scaled predictors. Each row represent one sample from the Conditional posterior of single index parameter.}
\item{beta}{ \code{M} \eqn{x p} Matrix of parameters corresponding to original predictors.}
\item{sigma.sq.eps}{ \code{M} \eqn{x 1} Vector; Sample of size \eqn{M} drawn from the Conditional posterior of the Error Variance.}
\item{X.scaled}{ \eqn{n x p} Matrix of scaled predictors. Each row has euclidean norm less than or equal to \eqn{1}.}
\item{knots}{  \eqn{(L+1) x 1} Vector of knots used for estimation of the link function.}
}
\description{
Performs a Markov Chain Monte Carlo algorithm to generate samples from the conditional posterior distribution of unknown parameters in a monotone Single Index Model - the unknown parameters being B-Spline basis coefficients that approximate the unknown link function, the single index parameter and the error variance of the model.
}
\details{
A Single Index Model of the form: \eqn{y = g(x^T \beta) + \epsilon} is considered.

The unknown link function, \eqn{g(.)} is approximated by a B-Spline basis expansion with coefficients \eqn{\xi} and basis functions defined using \code{knots}: \eqn{-1 = u_0 < u_1 < \dots < u_L = 1}. If \code{monotone = TRUE}, a truncated Normal \eqn{_+ (0, \Sigma_\xi)} distribution is assigned to \eqn{\xi} and the posterior samples are generated by an exact Hamiltonian Monte Carlo Algorithm. If \code{monotone = FALSE}, Normal \eqn{(0, \Sigma_\xi)} prior is assigned and the samples are generated from the corresponding posterior Normal distribution.
Note: Here \eqn{g(x) = 0,} when \eqn{x \le -1} and \eqn{g(x) = g(1),} when \eqn{x \ge 1}. The \code{X} matrix is scaled so that every row has euclidean norm \eqn{\le 1} and euclidean norm of \eqn{\beta} is taken to be 1 so that \eqn{|x^T \beta| \le 1}.

A normalized Gaussian prior with mean 0 and variance \eqn{\sigma_\beta^2} is assigned on the single index parameter, \eqn{\beta} and the posterior samples are generated using an Elliptical Slice Sampler.

The random errors, \eqn{\epsilon} follow a Normal distribution with mean 0 and variance \eqn{\sigma_\epsilon^2}. An inverse gamma prior with shape = \eqn{a_\epsilon} and rate = \eqn{b_\epsilon} is assigned to the error variance, and samples are generated from the corresponding posterior distribution.
}
\examples{
n=100; p=3; L = 20

# We take 2 continuous variables and 1 dichotomous attribute as predictors.
X = matrix(rnorm(n*(p-1)), nrow = n, ncol = (p-1))
X = cbind(X, rbinom(n, 1, 0.5))

# True Value of the parameter (having unit euclidean norm).
true.beta = rnorm(p); true.beta = true.beta/ norm(true.beta, "2")

beta.start = rnorm(p)  #Starting value of beta
xi = abs(rnorm((L+1), 0, 5))   #Starting value of xi
S_xi = 5*diag(L+1) #Prior Variance of xi
sigma.sq.eps.start = 0.01 #Starting value of sigma.sq.eps

# True monotone link function
true.g = function(x){
y = (x+1)/2
5*(pnorm(y, mean=0.5, sd=0.1) - pnorm(0, mean = 0.5, sd = 0.1))
}

# Generate the response
y.true = true.g(X\%*\%true.beta) + rnorm(n, 0, sqrt(sigma.sq.eps.start))

MCMC.sample = monotoneSIM(y = y.true, X = X, beta.init = beta.start,
  xi.init = xi, Sigma.xi =  S_xi, monotone = TRUE,
  sigma.sq.eps.init = sigma.sq.eps.start, Burn.in = 100, M = 500)

#Posterior mean of beta
beta.estimated = colMeans(MCMC.sample$beta); beta.estimated
true.beta  #Compare with true beta

#Posterior Standard Deviation of beta
sd.beta = apply(MCMC.sample$beta, 2, sd); sd.beta
}
\references{
Pakman, A. and Paninski, L. (2014) Exact Hamiltonian Monte Carlo for Truncated Multivariate Gaussians. \emph{Journal of Computational and Graphical Statistics}, \url{https://arxiv.org/abs/1208.4118}

Murray, I., Prescott Adams, R., and MacKay, D. J. (2010) Elliptical slice sampling. \emph{AISTATS, pages 541-548}, \url{https://arxiv.org/abs/1001.0175}
}
